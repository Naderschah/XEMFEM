// -------- 3D Single Phase TPC --------
SetFactory("OpenCASCADE");
Mesh.MshFileVersion = 2.2;
Mesh.SaveAll = 0; // write ONLY Physical groups

DriftRegionHeight    = @DriftRegionHeight@;    
n_wires              = @n_wires@;  
wire_diameter        = @wire_diameter@;  
inner_radius         = @inner_radius@;  
outer_radius         = @outer_radius@;  

anode_wire_height    = @anode_wire_height@;
cathode_wire_height  = @cathode_wire_height@;
ring_thickness       = @ring_thickness@;

H = DriftRegionHeight + ring_thickness * 2;
R = outer_radius * 1.1;

// ===== Outer Background Volume =====
//background_vol = newv;
//Cylinder(background_vol) = { 0, 0, 0,
//                             0, 0, H,
//                             R };
//Hide {
//  Volume{ background_vol };
//}


// --------- Generate the Cathode Wires & Ring ----------
// Generate Cathode Wires
cathode_wires[] = {};
xc_int         = 0.0;                 // center along X for anode row
zc_int         = cathode_wire_height;   // anode Z
wire_diam_int  = wire_diameter;
R_inner_int    = inner_radius;
n_wires_int    = n_wires;
r_int    = wire_diam_int/2;
Reff_int = R_inner_int - r_int;
If (n_wires_int > 0)
  If (Reff_int > 0)
    den_int = Max(1, n_wires_int - 1); // avoid division by zero
    For idx_int In {1 : n_wires_int}
      // idx=1 → y=-Reff, idx=n → y=+Reff; if n=1 → y=0
      y_int = Reff_int * ( (2*(idx_int - 1) - (n_wires_int - 1)) / den_int );
      // Compute extra such that wire is fully contained in electrode ring
      delta_int = Max(0, Abs(y_int) - r_int);
      // chord length at this y
      L_int = 2 * Sqrt( Max(0, R_inner_int^2 - delta_int^2) );
      If (L_int > 0)
        w_int = newv;
        Cylinder(w_int) = { xc_int - L_int/2, y_int, zc_int,  L_int, 0, 0,  r_int };
        cathode_wires[] += { w_int };
      EndIf
    EndFor
  EndIf
EndIf
// Generate Ring Electrode
cath_outer_vol = newv;
Cylinder(cath_outer_vol) = { 0, 0, cathode_wire_height - wire_diameter,
                             0, 0, ring_thickness, outer_radius };
cath_inner_vol = newv;
Cylinder(cath_inner_vol) = { 0, 0, cathode_wire_height - wire_diameter,
                             0, 0, ring_thickness, inner_radius };
cath_ring_vols[] = BooleanDifference{ Volume{ cath_outer_vol }; }{ Volume{ cath_inner_vol }; };
// Merge and get surface
cath_solid_vols[] = BooleanUnion{ Volume{ cath_ring_vols[] }; }{ Volume{ cathode_wires[] }; };
cath_bdr_surfs[] = Boundary{ Volume{ cath_solid_vols[] }; };
// Delete portions no longer required (everything but the surface and the volume)
Hide {
  Volume{ cath_solid_vols[] };
  Volume{ cath_ring_vols[] };
  Volume{ cath_outer_vol, cath_inner_vol };
  Volume{ cathode_wires[] };
}



// --------- Generate the Anode Wires & Ring ----------
// Generate Anode Wires
anode_wires[] = {};
xc_int         = 0.0;                  // center along X for anode row
zc_int         = anode_wire_height;    // anode Z
wire_diam_int  = wire_diameter;
R_inner_int    = inner_radius;
n_wires_int    = n_wires;
r_int          = wire_diam_int/2;
Reff_int       = R_inner_int - r_int;
If (n_wires_int > 0)
  If (Reff_int > 0)
    den_int = Max(1, n_wires_int - 1); // avoid division by zero
    For idx_int In {1 : n_wires_int}
      // idx=1 → y=-Reff, idx=n → y=+Reff; if n=1 → y=0
      y_int = Reff_int * ( (2*(idx_int - 1) - (n_wires_int - 1)) / den_int );
      // fully contained chord (innermost line touches inner ring)
      delta_int = Max(0, Abs(y_int) - r_int);
      L_int = 2 * Sqrt( Max(0, R_inner_int^2 - delta_int^2) );
      If (L_int > 0)
        w_int = newv;
        Cylinder(w_int) = { xc_int - L_int/2, y_int, zc_int,  L_int, 0, 0,  r_int };
        anode_wires[] += { w_int };
      EndIf
    EndFor
  EndIf
EndIf
// Generate Ring Electrode (anode)
an_outer_vol = newv;
Cylinder(an_outer_vol) = { 0, 0, anode_wire_height - wire_diameter,
                           0, 0, ring_thickness, outer_radius };
an_inner_vol = newv;
Cylinder(an_inner_vol) = { 0, 0, anode_wire_height - wire_diameter,
                           0, 0, ring_thickness, inner_radius };
an_ring_vols[] = BooleanDifference{ Volume{ an_outer_vol }; }{ Volume{ an_inner_vol }; };
// Merge and get surface
an_solid_vols[] = BooleanUnion{ Volume{ an_ring_vols[] }; }{ Volume{ anode_wires[] }; };
an_bdr_surfs[]  = Boundary{ Volume{ an_solid_vols[] }; };
// Delete portions no longer required (everything but the surface and the volume)
Hide {
  Volume{ an_solid_vols[] };
  Volume{ an_ring_vols[] };
  Volume{ an_outer_vol, an_inner_vol };
  Volume{ anode_wires[] };
}


// ----- Remove Solids from Background Volume ---------
// Frag[] = BooleanFragments{ Volume{ background_vol }; }{ Volume{ cath_solid_vols[], an_solid_vols[] }; };
// partitioned_volume = Frag[0];

// Physical Volume(@TPC_Volume_index@) = { partitioned_volume };
//Physical Surface(@cathode_BC_index@) = { cath_bdr_surfs[] };
Physical Surface(@anode_BC_index@) = { an_bdr_surfs[] };

// ---------- Delete straglers ----------


// ---------- Meshing controls ----------
Mesh.MeshOnlyVisible = 1; 

Mesh.Optimize = 1;
Mesh.CharacteristicLengthMax = Sqrt(outer_radius^2 * 3.14 + DriftRegionHeight^2) / 100;  // tune as you like
