// -------- 3D Single Phase TPC --------
SetFactory("OpenCASCADE");
Mesh.MshFileVersion = 2.2;
Mesh.SaveAll = 0; // write ONLY Physical groups

DriftRegionHeight    = @DriftRegionHeight@;    
n_wires              = @n_wires@;  
wire_diameter        = @wire_diameter@;  
inner_radius         = @inner_radius@;  
outer_radius         = @outer_radius@;  

anode_wire_height    = @anode_wire_height@;
cathode_wire_height  = @cathode_wire_height@;
ring_thickness       = @ring_thickness@;

H = DriftRegionHeight + ring_thickness * 2;
R = outer_radius;

// --------- Generate the Wires ----------

// Generate Anode Wires
anode_wires[] = {};
xc_int         = 0.0;                 // center along X for anode row
zc_int         = anode_wire_height;   // anode Z
wire_diam_int  = wire_diameter;
R_inner_int    = inner_radius;
n_wires_int    = n_wires;
r_int    = wire_diam_int/2;
Reff_int = R_inner_int - r_int;
If (n_wires_int > 0)
  If (Reff_int > 0)
    den_int = Max(1, n_wires_int - 1); // avoid division by zero
    For idx_int In {1 : n_wires_int}
      // idx=1 → y=-Reff, idx=n → y=+Reff; if n=1 → y=0
      y_int = Reff_int * ( (2*(idx_int - 1) - (n_wires_int - 1)) / den_int );
      // Compute extra such that wire is fully contained in electrode ring
      delta_int = Max(0, Abs(y_int) - r_int);
      // chord length at this y
      L_int = 2 * Sqrt( Max(0, R_inner_int^2 - delta_int^2) );
      If (L_int > 0)
        w_int = newv;
        Cylinder(w_int) = { xc_int - L_int/2, y_int, zc_int,  L_int, 0, 0,  r_int };
        anode_wires[] += { w_int };
      EndIf
    EndFor
  EndIf
EndIf



// Generate Cathode Wires
cathode_wires[] = {};
xc_int         = 0.0;                 // center along X for anode row
zc_int         = cathode_wire_height;   // anode Z
wire_diam_int  = wire_diameter;
R_inner_int    = inner_radius;
n_wires_int    = n_wires;
r_int    = wire_diam_int/2;
Reff_int = R_inner_int - r_int;
If (n_wires_int > 0)
  If (Reff_int > 0)
    den_int = Max(1, n_wires_int - 1); // avoid division by zero
    For idx_int In {1 : n_wires_int}
      // idx=1 → y=-Reff, idx=n → y=+Reff; if n=1 → y=0
      y_int = Reff_int * ( (2*(idx_int - 1) - (n_wires_int - 1)) / den_int );
      // Compute extra such that wire is fully contained in electrode ring
      delta_int = Max(0, Abs(y_int) - r_int);
      // chord length at this y
      L_int = 2 * Sqrt( Max(0, R_inner_int^2 - delta_int^2) );
      If (L_int > 0)
        w_int = newv;
        Cylinder(w_int) = { xc_int - L_int/2, y_int, zc_int,  L_int, 0, 0,  r_int };
        cathode_wires[] += { w_int };
      EndIf
    EndFor
  EndIf
EndIf


//              Generate Anode And Cathode Rings (and merge the volume + surface)
// anode
outer_ring_anode = newv; Cylinder(outer_ring_anode) = { 0, 0, anode_wire_height - ring_thickness + wire_diameter,   0, 0, ring_thickness,   outer_radius};
inner_ring_anode = newv; Cylinder(inner_ring_anode) = { 0, 0, anode_wire_height - ring_thickness + wire_diameter,   0, 0, ring_thickness,   inner_radius};
AnodeRing[] = BooleanDifference{ Volume{ outer_ring_anode }; Delete; }{ Volume{ inner_ring_anode }; Delete; };
AnodeSolid[] = BooleanUnion{ Volume{ AnodeRing[] }; Delete; }{ Volume{ anode_wires[] }; Delete; };

//cathode
outer_ring_cat = newv; Cylinder(outer_ring_cat) = { 0, 0, cathode_wire_height-wire_diameter,   0, 0, ring_thickness,   outer_radius};
inner_ring_cat = newv; Cylinder(inner_ring_cat) = { 0, 0, cathode_wire_height-wire_diameter,   0, 0, ring_thickness,   inner_radius};
CathodeRing[] = BooleanDifference{ Volume{ outer_ring_cat }; Delete; }{ Volume{ inner_ring_cat }; Delete; };
CathodeSolid[] = BooleanUnion{ Volume{ CathodeRing[] }; Delete; }{ Volume{ cathode_wires[] }; Delete; };


//              Create Background Volume and Remove from it 
BakgroundVolume = newv; Cylinder(BakgroundVolume) = { 0, 0, 0,   0, 0, H,   R}; 
// remove anode
Frag[] = BooleanFragments{ Volume{BakgroundVolume}; Delete; }{ Volume{AnodeSolid}; Delete; };
BakgroundVolume = Frag[0];
AnodeSolid = Frag[1];
// remove cathode
Frag[] = BooleanFragments{ Volume{BakgroundVolume}; Delete; }{ Volume{CathodeSolid}; Delete; };
BakgroundVolume = Frag[0];
CathodeSolid = Frag[1];


//              Define final volumes and surfaces
// Define PTFE Volume
outer_ring = newv;
ptfe_cylinder_height = (anode_wire_height - cathode_wire_height);
Cylinder(outer_ring) = { 0, 0, cathode_wire_height,   0, 0, ptfe_cylinder_height,   outer_radius};
inner_ring = newv;
Cylinder(inner_ring) = { 0, 0, cathode_wire_height,   0, 0, ptfe_cylinder_height,   inner_radius};
Diff[] = BooleanDifference{ Volume{ outer_ring }; Delete; }{ Volume{ inner_ring }; Delete; };
PTFE_Wall = Diff[0];
Frag[] = BooleanFragments{ Volume{BakgroundVolume}; Delete; }{ Volume{PTFE_Wall}; Delete; };
LXeVolume = Frag[0];
PTFE_Wall = Frag[1];

Physical Volume(2) = { PTFE_Wall };
Physical Volume(3) = { LXeVolume };

AnodeSolidBoundary[] = Boundary{ Volume{AnodeSolid}; };
Physical Surface(@anode_BC_index@)   = { AnodeSolidBoundary[] };
CathodeSolidBoundary[] = Boundary{ Volume{CathodeSolid}; };
Physical Surface(@cathode_BC_index@)   = { CathodeSolidBoundary[] };

// ---------- Delete Volumes that produce issues in meshing ------------
// For this to work if their surfaces are required they must have been created with BooleanFragments
// Otherwise the reference is lost 
Delete { 
  Volume{AnodeSolid}; 
  Volume{CathodeSolid}; 
}

// ---------- Meshing controls ----------
Mesh.Optimize = 1;
Mesh.CharacteristicLengthMax = Sqrt(outer_radius^2 * 3.14 + DriftRegionHeight^2) / 50;  // tune as you like
