import numpy as np
from pathlib import Path
import re
import subprocess

# Requires PyYAML (pip install pyyaml)
import yaml

"""
Supports both old and new geometry conventions for field-shaping rings/guards.

Old geometry:
  - Top Field Cage has maximum index
  - Top Guard has maximum index

New geometry:
  - Top Field Cage has minimum index
  - Top Guard has minimum index

Controlled by INVERT_FIELDCAGE_INDEX_ORIENTATION.

Additionally:
- Reads ./config.yaml and, if mesh.autoappend: true, will inject/replace the autogenerated
  sections (materials, boundaries, fieldcage_network) into config.yaml.
"""

# ============================================================
# USER CONFIG
# ============================================================

# False = old (top=max index). True = new (top=min index).
INVERT_FIELDCAGE_INDEX_ORIENTATION = True

# Volumes in phys_map → epsilon_r
volume_materials = {
    "LXeGroup":   1.95,
    "LXe":        1.95,
    "GXeGroup":   1.0,
    "GXe":        1.0,
    "PTFE_Group": 2.1,
    "PTFE":       2.1,
}

# Resistor values
R1 = 1.25e9
R2 = 2.5e9
R3 = 5e9
R_C = 7.0e9

# Paths
config_path   = Path("config.yaml")                 # existing user config
med_path      = Path("mesh/mesh.med")
msh_path      = Path("mesh/mesh22.msh")
phys_map_path = Path("mesh/phys_map.txt")
output_path   = Path("mesh/config_autogen.yaml")    # autogen output (always written)

# ============================================================
# 0. Mesh Preprocessing
# ============================================================

cmd = ["gmsh", "-0", str(med_path), "-format", "msh2", "-o", str(msh_path)]
subprocess.run(cmd, check=True)

def extract_physical_names(msh_path: Path, out_txt: Path) -> None:
    in_block = False
    with msh_path.open("r", encoding="utf-8", errors="replace") as f_in, \
         out_txt.open("w", encoding="utf-8") as f_out:
        for line in f_in:
            s = line.strip()
            if s == "$PhysicalNames":
                in_block = True
                continue
            if s == "$EndPhysicalNames":
                in_block = False
                break
            if in_block:
                f_out.write(line)

extract_physical_names(msh_path, phys_map_path)

grounded = {"type": "dirichlet", "value": 0}

# ============================================================
# 1. PARSE phys_map.txt
# ============================================================

_last_int_re = re.compile(r"(\d+)(?!.*\d)")

def extract_index(name: str, prefix: str) -> int | None:
    if not name.startswith(prefix):
        return None
    m = _last_int_re.search(name)
    if not m:
        return None
    return int(m.group(1))

def parse_phys_map(path: Path):
    with path.open() as f:
        lines = [l.strip() for l in f if l.strip()]

    n_total = int(lines[0])
    entries = lines[1:]

    regions = {}    # dim==2
    boundaries = {} # dim==1

    for line in entries:
        dim_s, tag_s, name_s = line.split(maxsplit=2)
        dim = int(dim_s)
        tag = int(tag_s)
        name = name_s.strip('"')

        if dim == 1:
            boundaries[name] = {"bdr_id": tag}
        elif dim == 2:
            regions[name] = {"attr_id": tag}
        else:
            raise ValueError(f"Unexpected dim {dim} in phys_map line: {line}")

    print(f"[parse] total entries in phys_map: {n_total}")
    print(f"[parse] boundaries: {len(boundaries)}, regions: {len(regions)}")
    return regions, boundaries

regions_raw, boundaries_raw = parse_phys_map(phys_map_path)

# ============================================================
# 1b. NAME ALIASES (OLD → NEW)
# ============================================================

def resolve_boundary_name(boundaries: dict, candidates: list[str]) -> str | None:
    for c in candidates:
        if c in boundaries:
            return c
    return None

BC_NAME = {
    "TOP_SCREEN":    ["BC_TopScreeningElectrode", "BC_TopScreen"],
    "ANODE":         ["BC_AnodeElectrode", "BC_Anode"],
    "GATE":          ["BC_GateElectrode", "BC_Gate"],
    "CATHODE":       ["BC_CathodeElectrode", "BC_Cathode"],
    "BOTTOM_SCREEN": ["BC_BottomScreeningElectrode", "BC_BottomScreen"],
    "PMTS":          ["BC_AllPMTs", "BC_PMT"],
    "BELL":          ["BC_Bell"],
    "COPPER_RING":   ["BC_CopperRing"],
    "CRYOSTAT":      ["BC_Cryostat"],
}

bc_top_screen   = resolve_boundary_name(boundaries_raw, BC_NAME["TOP_SCREEN"])
bc_anode        = resolve_boundary_name(boundaries_raw, BC_NAME["ANODE"])
bc_gate         = resolve_boundary_name(boundaries_raw, BC_NAME["GATE"])
bc_cathode      = resolve_boundary_name(boundaries_raw, BC_NAME["CATHODE"])
bc_bottomscreen = resolve_boundary_name(boundaries_raw, BC_NAME["BOTTOM_SCREEN"])
bc_pmts         = resolve_boundary_name(boundaries_raw, BC_NAME["PMTS"])
bc_bell         = resolve_boundary_name(boundaries_raw, BC_NAME["BELL"])
bc_copper_ring  = resolve_boundary_name(boundaries_raw, BC_NAME["COPPER_RING"])
bc_cryostat     = resolve_boundary_name(boundaries_raw, BC_NAME["CRYOSTAT"])

required = {
    "TOP_SCREEN": bc_top_screen,
    "ANODE": bc_anode,
    "GATE": bc_gate,
    "CATHODE": bc_cathode,
    "BOTTOM_SCREEN": bc_bottomscreen,
    "PMTS": bc_pmts,
    "BELL": bc_bell,
    "COPPER_RING": bc_copper_ring,
    "CRYOSTAT": bc_cryostat,
}
missing = [k for k, v in required.items() if v is None]
if missing:
    print("[warning] Missing expected boundary names in phys_map:")
    for k in missing:
        print(f"  - {k}: tried {BC_NAME[k]}")
    print("[warning] Script will proceed, but those BCs will be skipped if unresolved.")

# ============================================================
# Fixed boundary conditions
# ============================================================

fixed_boundaries = {
    bc_top_screen:   {"type": "dirichlet", "value": -1500},
    bc_anode:        {"type": "dirichlet", "value": 6500},
    bc_gate:         {"type": "dirichlet", "value": -1000},

    # Intended TOP-ring voltage (will be rebound to actual top ring name in phys_map)
    "BC_FieldShapingRings70": {"type": "dirichlet", "value": -950.},

    bc_cathode:      {"type": "dirichlet", "value": -30000},
    bc_bottomscreen: {"type": "dirichlet", "value": -1500},

    bc_pmts:         {"type": "dirichlet", "value": -1300},
    bc_bell:         grounded,
    bc_copper_ring:  grounded,
    bc_cryostat:     grounded,
}

fixed_boundaries = {k: v for k, v in fixed_boundaries.items() if k is not None}

# ============================================================
# 2. COLLECT RING/GUARD NAMES + NORMALIZE FIXED RING BCS
# ============================================================

def fc_sort_reverse() -> bool:
    return not INVERT_FIELDCAGE_INDEX_ORIENTATION

def pick_top_ring(fieldcage_names: list[str]) -> str:
    parsed = [(n, extract_index(n, "BC_FieldShapingRings")) for n in fieldcage_names]
    parsed = [(n, idx) for (n, idx) in parsed if idx is not None]
    if not parsed:
        raise RuntimeError("Could not extract indices from BC_FieldShapingRings* names.")
    return (min if INVERT_FIELDCAGE_INDEX_ORIENTATION else max)(parsed, key=lambda t: t[1])[0]

def pick_bottom_ring(fieldcage_names: list[str]) -> str:
    parsed = [(n, extract_index(n, "BC_FieldShapingRings")) for n in fieldcage_names]
    parsed = [(n, idx) for (n, idx) in parsed if idx is not None]
    if not parsed:
        raise RuntimeError("Could not extract indices from BC_FieldShapingRings* names.")
    return (max if INVERT_FIELDCAGE_INDEX_ORIENTATION else min)(parsed, key=lambda t: t[1])[0]

def normalize_fixed_fieldcage_ring_bcs(
    fixed_bcs: dict,
    fieldcage_names_in_file: list[str],
) -> tuple[dict, str, str]:
    ring_keys = [k for k in fixed_bcs if isinstance(k, str) and k.startswith("BC_FieldShapingRings")]
    if not ring_keys:
        return fixed_bcs, "", ""

    if not fieldcage_names_in_file:
        raise RuntimeError("fixed_boundaries contains ring BCs but no BC_FieldShapingRings* exist in phys_map.")

    top_name = pick_top_ring(fieldcage_names_in_file)
    bottom_name = pick_bottom_ring(fieldcage_names_in_file)

    provided = [(k, extract_index(k, "BC_FieldShapingRings"), fixed_bcs[k]) for k in ring_keys]

    fixed_bcs2 = dict(fixed_bcs)
    for k in ring_keys:
        fixed_bcs2.pop(k, None)

    if len(provided) == 1:
        fixed_bcs2[top_name] = provided[0][2]
        return fixed_bcs2, top_name, bottom_name

    with_idx = [(k, idx, bc) for (k, idx, bc) in provided if idx is not None]
    if with_idx:
        if INVERT_FIELDCAGE_INDEX_ORIENTATION:
            top_like = min(with_idx, key=lambda t: t[1])
            bottom_like = max(with_idx, key=lambda t: t[1])
        else:
            top_like = max(with_idx, key=lambda t: t[1])
            bottom_like = min(with_idx, key=lambda t: t[1])

        fixed_bcs2[top_name] = top_like[2]
        if bottom_name != top_name:
            fixed_bcs2[bottom_name] = bottom_like[2]
    else:
        fixed_bcs2[top_name] = provided[0][2]
        if bottom_name != top_name:
            fixed_bcs2[bottom_name] = provided[1][2]

    return fixed_bcs2, top_name, bottom_name

def is_ring_or_guard(name: str) -> bool:
    return name.startswith("BC_FieldShapingRings") or name.startswith("BC_FieldShapingGuard")

fieldcage_names = [name for name in boundaries_raw if name.startswith("BC_FieldShapingRings")]
guard_names     = [name for name in boundaries_raw if name.startswith("BC_FieldShapingGuard")]

print(f"[network] BC_FieldShapingRings*: {len(fieldcage_names)}, BC_FieldShapingGuard*: {len(guard_names)}")

fixed_boundaries, top_fc_name, bottom_fc_name = normalize_fixed_fieldcage_ring_bcs(
    fixed_boundaries,
    fieldcage_names,
)

if fieldcage_names and not top_fc_name:
    raise RuntimeError(
        "BC_FieldShapingRings* exist in phys_map but fixed_boundaries has no ring entry. "
        "Add one ring entry (treated as TOP), or two (TOP and BOTTOM)."
    )

# ============================================================
# 3. COMPUTE VOLTAGES FOR BC_FieldShapingRings* AND BC_FieldShapingGuard*
# ============================================================

def solve_fieldcage_network(fieldcage_names, guard_names, V_top, V_cathode, cathode_bc_name: str):
    if not fieldcage_names:
        return {}

    fieldcage_names = sorted(
        fieldcage_names,
        key=lambda n: extract_index(n, "BC_FieldShapingRings"),
        reverse=fc_sort_reverse(),
    )
    guard_names = sorted(
        guard_names,
        key=lambda n: extract_index(n, "BC_FieldShapingGuard"),
        reverse=fc_sort_reverse(),
    )

    fc     = fieldcage_names
    guards = guard_names
    n_fc   = len(fc)
    n_guard = len(guards)

    fixed_V = {
        fc[0]:     V_top,
        "Cathode": V_cathode,
    }

    unknown_nodes = list(fc[1:]) + list(guards)
    N = len(unknown_nodes)
    if N == 0:
        return {fc[0]: V_top}

    node_index = {name: i for i, name in enumerate(unknown_nodes)}
    G = np.zeros((N, N), dtype=float)
    b = np.zeros(N, dtype=float)

    def add_resistor(a, bnode, R):
        g = 1.0 / R

        a_unknown = a in node_index
        b_unknown = bnode in node_index
        a_fixed   = a in fixed_V
        b_fixed   = bnode in fixed_V

        if a_unknown and b_unknown:
            ia = node_index[a]
            ib = node_index[bnode]
            G[ia, ia] += g
            G[ib, ib] += g
            G[ia, ib] -= g
            G[ib, ia] -= g
        elif a_unknown and b_fixed:
            ia = node_index[a]
            G[ia, ia] += g
            b[ia] += g * fixed_V[bnode]
        elif b_unknown and a_fixed:
            ib = node_index[bnode]
            G[ib, ib] += g
            b[ib] += g * fixed_V[a]
        else:
            pass

    if n_fc < 8 or n_guard == 0:
        for i in range(n_fc - 1):
            add_resistor(fc[i], fc[i + 1], R1)
        add_resistor(fc[-1], "Cathode", R_C)
    else:
        for i in range(0, 4):
            add_resistor(fc[i], fc[i + 1], R1)

        if n_fc > 5:
            add_resistor(fc[4], fc[5], R2)
        if n_guard > 0:
            add_resistor(fc[4], guards[0], R2)

        merge_index = n_fc - 3

        for i in range(5, merge_index):
            add_resistor(fc[i], fc[i + 1], R3)

        for j in range(0, n_guard - 1):
            add_resistor(guards[j], guards[j + 1], R3)

        if n_guard > 0:
            add_resistor(guards[-1], fc[merge_index], R2)

        for i in range(merge_index, n_fc - 1):
            add_resistor(fc[i], fc[i + 1], R1)

        add_resistor(fc[-1], "Cathode", R_C)

    V_unknown = np.linalg.solve(G, b)

    voltages = dict(fixed_V)
    for name, idx in node_index.items():
        voltages[name] = float(V_unknown[idx])

    V1 = voltages[fc[0]]
    Vc = fixed_boundaries[cathode_bc_name]["value"]
    drop_direct = V1 - Vc

    drop_fc_chain = 0.0
    for a, bnode in zip(fc, fc[1:]):
        drop_fc_chain += voltages[a] - voltages[bnode]
    drop_fc_chain += voltages[fc[-1]] - Vc

    print(f"[check] ΔV(TopRing→Cathode) (direct) = {drop_direct:.6g}")
    print(f"[check] ΔV via FieldCage chain      = {drop_fc_chain:.6g} (Δ = {drop_fc_chain - drop_direct:+.3e})")

    return voltages

fc_voltages = solve_fieldcage_network(
    fieldcage_names,
    guard_names,
    V_top=fixed_boundaries[top_fc_name]["value"],
    V_cathode=fixed_boundaries[bc_cathode]["value"],
    cathode_bc_name=bc_cathode,
)

# ============================================================
# 4. BUILD MATERIALS + BOUNDARIES DATA
# ============================================================

materials = {}
missing_material_eps = []
for name, meta in regions_raw.items():
    if name in volume_materials:
        materials[name] = {"attr_id": meta["attr_id"], "epsilon_r": volume_materials[name]}
    else:
        missing_material_eps.append(name)

if missing_material_eps:
    print("[warning] No epsilon_r specified for materials:")
    for name in sorted(missing_material_eps):
        print(f"  - {name}")

# Fixed boundaries output (EXCLUDE rings/guards so rings print contiguously)
boundaries_fixed_out = {}
for name, bc in fixed_boundaries.items():
    if is_ring_or_guard(name):
        continue
    if name not in boundaries_raw:
        print(f"[warning] Fixed boundary '{name}' not found in phys_map; skipping.")
        continue
    tag = boundaries_raw[name]["bdr_id"]
    boundaries_fixed_out[name] = {"bdr_id": tag, "type": bc["type"], "value": bc["value"]}

# Rings/guards output
boundaries_rings = {}
for name in fieldcage_names:
    tag = boundaries_raw[name]["bdr_id"]
    boundaries_rings[name] = {"bdr_id": tag, "type": "dirichlet", "value": float(fc_voltages[name])}
for name in guard_names:
    tag = boundaries_raw[name]["bdr_id"]
    boundaries_rings[name] = {"bdr_id": tag, "type": "dirichlet", "value": float(fc_voltages[name])}

assigned_boundary_names = set(boundaries_fixed_out) | set(boundaries_rings)
unassigned_boundaries = sorted(name for name in boundaries_raw if name not in assigned_boundary_names)

if unassigned_boundaries:
    print("[warning] The following boundaries have no assigned voltage:")
    for name in unassigned_boundaries:
        tag = boundaries_raw[name]["bdr_id"]
        print(f"  - {name} (bdr_id={tag})")
else:
    print("[info] All boundaries in phys_map have an assigned voltage.")

# ============================================================
# 5. BUILD FIELDCAGE NETWORK DESCRIPTION FOR CONFIG
# ============================================================

fieldcage_names_sorted = sorted(
    fieldcage_names,
    key=lambda n: extract_index(n, "BC_FieldShapingRings"),
    reverse=fc_sort_reverse(),
)
guard_names_sorted = sorted(
    guard_names,
    key=lambda n: extract_index(n, "BC_FieldShapingGuard"),
    reverse=fc_sort_reverse(),
)

n_fc = len(fieldcage_names_sorted)
n_guard = len(guard_names_sorted)

nodes_desc = []
edges_desc = []

if n_fc > 0:
    for name in fieldcage_names_sorted:
        nodes_desc.append({"name": name, "boundary": name, "fixed": (name == top_fc_name)})

for name in guard_names_sorted:
    nodes_desc.append({"name": name, "boundary": name, "fixed": False})

nodes_desc.append({"name": "Cathode", "boundary": bc_cathode, "fixed": True})

if n_fc > 0:
    fc = fieldcage_names_sorted
    guards = guard_names_sorted

    if n_fc < 8 or n_guard == 0:
        for i in range(n_fc - 1):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R1"})
        edges_desc.append({"n1": fc[-1], "n2": "Cathode", "R": "R_C"})
    else:
        for i in range(0, 4):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R1"})

        if n_fc > 5:
            edges_desc.append({"n1": fc[4], "n2": fc[5], "R": "R2"})
        if n_guard > 0:
            edges_desc.append({"n1": fc[4], "n2": guards[0], "R": "R2"})

        merge_index = n_fc - 3

        for i in range(5, merge_index):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R3"})
        for j in range(0, n_guard - 1):
            edges_desc.append({"n1": guards[j], "n2": guards[j + 1], "R": "R3"})

        if n_guard > 0:
            edges_desc.append({"n1": guards[-1], "n2": fc[merge_index], "R": "R2"})

        for i in range(merge_index, n_fc - 1):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R1"})

        edges_desc.append({"n1": fc[-1], "n2": "Cathode", "R": "R_C"})

# ============================================================
# 6. WRITE config_autogen.yaml (always)
# ============================================================

def sort_key_ring(n: str):
    # rings before guards; index ordering follows orientation
    if n.startswith("BC_FieldShapingGuard"):
        idx = extract_index(n, "BC_FieldShapingGuard")
        idx = 0 if idx is None else idx
        return (1, -idx if fc_sort_reverse() else idx)
    idx = extract_index(n, "BC_FieldShapingRings")
    idx = 0 if idx is None else idx
    return (0, -idx if fc_sort_reverse() else idx)

with output_path.open("w") as out:
    out.write("materials:\n")
    for m in sorted(materials):
        v = materials[m]
        out.write(f"  {m}:\n")
        out.write(f"    attr_id: {v['attr_id']}\n")
        out.write(f"    epsilon_r: {v['epsilon_r']}\n")

    out.write("\nboundaries:\n")

    for name in sorted(boundaries_fixed_out):
        v = boundaries_fixed_out[name]
        out.write(f"  {name}:\n")
        out.write(f"    bdr_id: {v['bdr_id']}\n")
        out.write(f"    type: {v['type']}\n")
        out.write(f"    value: {v['value']}\n")

    for name in sorted(boundaries_rings, key=sort_key_ring):
        if name in boundaries_fixed_out:
            continue
        v = boundaries_rings[name]
        out.write(f"  {name}:\n")
        out.write(f"    bdr_id: {v['bdr_id']}\n")
        out.write(f"    type: {v['type']}\n")
        out.write(f"    value: {v['value']}\n")

    out.write("\nfieldcage_network:\n")
    out.write("  enabled: true\n")

    out.write("  nodes:\n")
    for nd in nodes_desc:
        out.write(f"    - name: \"{nd['name']}\"\n")
        out.write(f"      boundary: \"{nd['boundary']}\"\n")
        out.write(f"      fixed: {str(nd['fixed']).lower()}\n")

    out.write("  resistors:\n")
    out.write(f"    R1: {R1}\n")
    out.write(f"    R2: {R2}\n")
    out.write(f"    R3: {R3}\n")
    out.write(f"    R_C: {R_C}\n")

    out.write("  edges:\n")
    for e in edges_desc:
        out.write(f"    - n1: \"{e['n1']}\"\n")
        out.write(f"      n2: \"{e['n2']}\"\n")
        out.write(f"      R: \"{e['R']}\"\n")

print(
    f"[done] Wrote {output_path} with {len(boundaries_rings)} FieldCage/guard boundaries "
    f"and {len(nodes_desc)} nodes / {len(edges_desc)} edges in fieldcage_network."
)

# ============================================================
# 7. OPTIONAL: AUTOAPPEND INTO ./config.yaml
# ============================================================

def yaml_load(path: Path) -> dict:
    if not path.exists():
        return {}
    txt = path.read_text(encoding="utf-8")
    data = yaml.safe_load(txt)
    return data if isinstance(data, dict) else {}

def yaml_dump(path: Path, data: dict) -> None:
    path.write_text(
        yaml.safe_dump(data, sort_keys=False, default_flow_style=False),
        encoding="utf-8",
    )

def mesh_autoappend_enabled(cfg: dict) -> bool:
    mesh = cfg.get("mesh", {})
    if not isinstance(mesh, dict):
        return False
    return bool(mesh.get("autoappend", False))

def apply_autogen_sections_inplace(cfg: dict, autogen: dict) -> dict:
    """
    Replace existing top-level sections if present, otherwise append them at the end
    (preserving existing key order as much as possible).
    """
    out = dict(cfg)  # preserves insertion order (Py3.7+)

    for key in ("materials", "boundaries", "fieldcage_network"):
        if key in out:
            out[key] = autogen[key]
        else:
            out[key] = autogen[key]  # appended at end

    return out
def resolve_and_update_mesh_path(cfg: dict, msh_path: Path) -> None:
    """
    If mesh.path exists in cfg, overwrite it with the resolved absolute path
    of msh_path. If msh_path does not exist, emit a colored warning.
    """
    mesh_cfg = cfg.get("mesh")
    if not isinstance(mesh_cfg, dict):
        return

    if not msh_path.exists():
        # yellow warning
        print(
            "\033[33m[warning]\033[0m mesh.path not updated: "
            f"{msh_path} does not exist."
        )
        return

    resolved = str(msh_path.resolve())
    mesh_cfg["path"] = resolved

cfg = yaml_load(config_path)
if mesh_autoappend_enabled(cfg):
    autogen_sections = {
        "materials": materials,
        "boundaries": {**boundaries_fixed_out, **{k: boundaries_rings[k] for k in sorted(boundaries_rings, key=sort_key_ring)}},
        "fieldcage_network": {
            "enabled": True,
            "nodes": nodes_desc,
            "resistors": {"R1": R1, "R2": R2, "R3": R3, "R_C": R_C},
            "edges": edges_desc,
        },
    }
    resolve_and_update_mesh_path(cfg, msh_path)

    new_cfg = apply_autogen_sections_inplace(cfg, autogen_sections)

    yaml_dump(config_path, new_cfg)
    print(f"[autoappend] Updated {config_path} (materials/boundaries/fieldcage_network).")
else:
    print(f"[autoappend] mesh.autoappend not enabled in {config_path}; no changes applied.")
