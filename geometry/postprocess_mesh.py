import numpy as np
import importlib.util
from pathlib import Path
import re
import subprocess
import sys, os
import meshio
from collections import defaultdict

# Requires PyYAML (pip install pyyaml)
import yaml

"""
Supports both old and new geometry conventions for field-shaping rings/guards.

Old geometry:
  - Top Field Cage has maximum index
  - Top Guard has maximum index

New geometry:
  - Top Field Cage has minimum index
  - Top Guard has minimum index

Controlled by INVERT_FIELDCAGE_INDEX_ORIENTATION.

Additionally:
- Reads ./config.yaml and, if mesh.autoappend: true, will inject/replace the autogenerated
  sections (materials, boundaries, fieldcage_network) into config.yaml.
"""

# Paths
config_path   = Path("config.yaml")                 # existing user config
med_path      = Path("mesh/mesh.med")
msh_path      = Path("mesh/mesh22.msh")
phys_map_path = Path("mesh/phys_map.txt")
output_path   = Path("mesh/config_autogen.yaml")    # autogen output (always written)

# ============================================================
# USER CONFIG
# ============================================================
def yaml_load(path: Path) -> dict:
    if not path.exists():
        return {}
    txt = path.read_text(encoding="utf-8")
    data = yaml.safe_load(txt)
    return data if isinstance(data, dict) else {}

cfg = yaml_load(config_path)

# Load voltages
to_use = cfg.get("mesh", {}).get("voltages", None)
if to_use is None:
    print("Please Provide which Voltages to load in the config file under mesh.voltage.\nGiven a string it will import get_bc from <string>_*.py")
    sys.exit(1)

fname = [i for i in os.listdir(".") if (i.endswith(".py") and (to_use in i))]
get_bc = None
print(fname)
for f in fname:
    try:
        module_name = Path(f).stem # Strip .py
        spec = importlib.util.spec_from_file_location(module_name, f)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        get_bc = module.get_bc
        break
    except Exception as e:
        pass
if get_bc is None:
    raise RuntimeError("Could not find Boundary condition function get_bc in any matched file\nIf there is a syntax error in it there will be no warning")


##                          Unchanged Constants
# Volumes in phys_map → epsilon_r
volume_materials = {
    "LXeGroup":   1.95,
    "LXe":        1.95,
    "GXeGroup":   1.0,
    "GXe":        1.0,
    "PTFE_Group": 2.1,
    "PTFE":       2.1,
}
# Resistor values
R1 = 1.25e9
R2 = 2.5e9
R3 = 5e9
R_C = 7.0e9

# Get our values
fixed_boundaries = get_bc()
# ============================================================
# 0. Mesh Preprocessing
# ============================================================

cmd = ["gmsh", "-0", str(med_path), "-format", "msh2", "-o", str(msh_path)]
subprocess.run(cmd, check=True)

def extract_physical_names(msh_path: Path, out_txt: Path) -> None:
    in_block = False
    with msh_path.open("r", encoding="utf-8", errors="replace") as f_in, \
         out_txt.open("w", encoding="utf-8") as f_out:
        for line in f_in:
            s = line.strip()
            if s == "$PhysicalNames":
                in_block = True
                continue
            if s == "$EndPhysicalNames":
                in_block = False
                break
            if in_block:
                f_out.write(line)

extract_physical_names(msh_path, phys_map_path)

# ============================================================
# 1. PARSE phys_map.txt
# ============================================================

_last_int_re = re.compile(r"(\d+)(?!.*\d)")

def extract_index(name: str, prefix: str) -> int | None:
    if not name.startswith(prefix):
        return None
    m = _last_int_re.search(name)
    if not m:
        return None
    return int(m.group(1))

def parse_phys_map(path: Path):
    with path.open() as f:
        lines = [l.strip() for l in f if l.strip()]

    n_total = int(lines[0])
    entries = lines[1:]

    regions = {}    # dim==2
    boundaries = {} # dim==1

    for line in entries:
        dim_s, tag_s, name_s = line.split(maxsplit=2)
        dim = int(dim_s)
        tag = int(tag_s)
        name = name_s.strip('"')

        if dim == 1:
            boundaries[name] = {"bdr_id": tag}
        elif dim == 2:
            regions[name] = {"attr_id": tag}
        else:
            raise ValueError(f"Unexpected dim {dim} in phys_map line: {line}")

    print(f"[parse] total entries in phys_map: {n_total}")
    print(f"[parse] boundaries: {len(boundaries)}, regions: {len(regions)}")
    return regions, boundaries

regions_raw, boundaries_raw = parse_phys_map(phys_map_path)
not_explicitly_assigned = [i for i in boundaries_raw if i not in fixed_boundaries.keys()]

# Collect BC groups (rings and guards and any faulty remaining)
_trailing_int = re.compile(r"^(.*?)(\d+)$")
def family_name(name: str) -> tuple[str, bool]:
    return ((m := _trailing_int.match(name)) and (m.group(1), True)) or (name, False)
rem_groups = {}
for name in not_explicitly_assigned:
    base, _ = family_name(name)
    rem_groups.setdefault(base, []).append(name)
if len(list(rem_groups.keys())) > 2: 
    raise Exception("A boundary condition specified in the mesh is not assigned a voltage ", [i for i in rem_groups.keys() if (i!="BC_FieldShapingRings") and (i!="BC_FieldShapingGuard")])

# Get the boundary names 
bc_guard = [i for i in rem_groups.keys() if 'guard' in i.lower()][0]
bc_ring = [i for i in rem_groups.keys() if bc_guard.lower() != i.lower()][0]

# Collect boundary conditions by index sorted by height 
mesh = meshio.read(med_path)
name_to_family_ids = defaultdict(set)
for fam_id, names in mesh.cell_tags.items():  # fam_id:int -> [groupname,...]
    for nm in names:
        name_to_family_ids[nm].add(int(fam_id))
if "cell_tags" not in mesh.cell_data:
    raise RuntimeError("mesh.cell_data has no 'cell_tags' (per-cell family ids).")

def yavg_for_group_name(mesh: meshio.Mesh, group_name: str) -> float:
    """
    Average Y of UNIQUE vertices belonging to all elements in the given MED group (element family).
    """
    fam_ids = name_to_family_ids.get(group_name)
    if not fam_ids:
        raise RuntimeError(f"Group '{group_name}' not found in MED element families (mesh.cell_tags).")
    used_point_ids = set()
    # cell_data["cell_tags"] aligns with mesh.cells blocks by index
    for block_idx, cell_block in enumerate(mesh.cells):
        tags = mesh.cell_data["cell_tags"][block_idx]  # fam_id per element in this block
        mask = np.isin(tags, list(fam_ids))
        if not np.any(mask):
            continue
        conn = cell_block.data[mask]  # (n_selected, nodes_per_cell)
        used_point_ids.update(map(int, np.unique(conn)))
    if not used_point_ids:
        raise RuntimeError(f"Group '{group_name}' has family ids {sorted(fam_ids)} but matched no elements/points.")
    y = mesh.points[list(used_point_ids), 1]  # <-- Y coordinate
    return float(np.mean(y))

ring_members  = [n for n in not_explicitly_assigned if bc_ring.lower()  in n.lower()]   # or "rings" if you want stricter
guard_members = [n for n in not_explicitly_assigned if bc_guard.lower() in n.lower()]

if not ring_members:
    raise RuntimeError("No ring electrodes found.")
if not guard_members:
    raise RuntimeError("No guard electrodes found.")

ring_y  = {n: yavg_for_group_name(mesh, n) for n in ring_members}
guard_y = {n: yavg_for_group_name(mesh, n) for n in guard_members}

ring_names_sorted  = sorted(ring_members,  key=lambda n: ring_y[n],  reverse=True)
guard_names_sorted = sorted(guard_members, key=lambda n: guard_y[n], reverse=True)

# Debug
if cfg.get("debug", {}).get("debug", {}):
    print("[order] Rings (high->low by avg y):")
    for n in ring_names_sorted[:20]:
        print(f"  {n}: y_avg={ring_y[n]:.6g}")
    print("[order] Guards (high->low by avg y):")
    for n in guard_names_sorted[:20]:
        print(f"  {n}: y_avg={guard_y[n]:.6g}")
# Mesh BC Sanity check
_last_int = re.compile(r"(\d+)(?!.*\d)")
def extract_idx(name: str) -> int:
    m = _last_int.search(name)
    if not m:
        raise RuntimeError(f"No trailing index found in boundary name '{name}'.")
    return int(m.group(1))
def check_monotonic_indices(sorted_names: list[str], label: str) -> None:
    idx = [extract_idx(n) for n in sorted_names]
    inc = all(a < b for a, b in zip(idx, idx[1:]))
    dec = all(a > b for a, b in zip(idx, idx[1:]))
    if not (inc or dec):
        lines = [
            f"[error] Non-monotonic index ordering detected for {label}:",
            "  order (name → index):",
        ]
        for n, i in zip(sorted_names, idx):
            lines.append(f"    {n} → {i}")
        lines.append(
            "Indices must be strictly increasing or strictly decreasing when "
            "sorted by geometric position. This likely indicates a mesh or naming issue."
        )
        raise RuntimeError("\n".join(lines))
    direction = "increasing" if inc else "decreasing"
    if cfg.get("debug", {}).get("debug", {}):
        print(f"[check] {label} indices are strictly {direction}.")
# ---- run checks ----
check_monotonic_indices(ring_names_sorted,  "Field-shaping rings")
check_monotonic_indices(guard_names_sorted, "Field-shaping guards")



fieldcage_names = ring_names_sorted      # already high -> low by geometry
guard_names     = guard_names_sorted     # already high -> low by geometry
top_fc_name = fieldcage_names[0] if fieldcage_names else ""
bottom_fc_name = fieldcage_names[-1] if fieldcage_names else ""

print(f"[network] BC_FieldShapingRings*: {len(fieldcage_names)}, BC_FieldShapingGuard*: {len(guard_names)}")

TOP_RING_PLACEHOLDER = "BC_TopFieldShaping"

top_fc_name = ring_names_sorted[0]
bottom_fc_name = ring_names_sorted[-1]
# Require placeholder
if TOP_RING_PLACEHOLDER not in fixed_boundaries:
    raise RuntimeError(
        f"Missing placeholder '{TOP_RING_PLACEHOLDER}' in fixed_boundaries. "
        "Add it in get_bc() as the intended TOP-ring voltage."
    )
# Extract placeholder BC
top_bc = fixed_boundaries.pop(TOP_RING_PLACEHOLDER)
# Safety: do not overwrite an explicitly specified ring BC
if top_fc_name in fixed_boundaries:
    raise RuntimeError(
        f"Both placeholder '{TOP_RING_PLACEHOLDER}' and concrete top ring '{top_fc_name}' "
        "exist in fixed_boundaries; keep only one."
    )
# Assign to actual mesh ring name
fixed_boundaries[top_fc_name] = top_bc


# ============================================================
# 3. COMPUTE VOLTAGES FOR BC_FieldShapingRings* AND BC_FieldShapingGuard*
# ============================================================

def solve_fieldcage_network(fieldcage_names, guard_names, V_top, V_cathode, cathode_bc_name: str):
    if not fieldcage_names:
        return {}

    fc = list(fieldcage_names)
    guards = list(guard_names)
    n_fc   = len(fc)
    n_guard = len(guards)

    fixed_V = {
        fc[0]:     V_top,
        "Cathode": V_cathode,
    }

    unknown_nodes = list(fc[1:]) + list(guards)
    N = len(unknown_nodes)
    if N == 0:
        return {fc[0]: V_top}

    node_index = {name: i for i, name in enumerate(unknown_nodes)}
    G = np.zeros((N, N), dtype=float)
    b = np.zeros(N, dtype=float)

    def add_resistor(a, bnode, R):
        g = 1.0 / R

        a_unknown = a in node_index
        b_unknown = bnode in node_index
        a_fixed   = a in fixed_V
        b_fixed   = bnode in fixed_V

        if a_unknown and b_unknown:
            ia = node_index[a]
            ib = node_index[bnode]
            G[ia, ia] += g
            G[ib, ib] += g
            G[ia, ib] -= g
            G[ib, ia] -= g
        elif a_unknown and b_fixed:
            ia = node_index[a]
            G[ia, ia] += g
            b[ia] += g * fixed_V[bnode]
        elif b_unknown and a_fixed:
            ib = node_index[bnode]
            G[ib, ib] += g
            b[ib] += g * fixed_V[a]
        else:
            pass

    if n_fc < 8 or n_guard == 0:
        for i in range(n_fc - 1):
            add_resistor(fc[i], fc[i + 1], R1)
        add_resistor(fc[-1], "Cathode", R_C)
    else:
        for i in range(0, 4):
            add_resistor(fc[i], fc[i + 1], R1)

        if n_fc > 5:
            add_resistor(fc[4], fc[5], R2)
        if n_guard > 0:
            add_resistor(fc[4], guards[0], R2)

        merge_index = n_fc - 3

        for i in range(5, merge_index):
            add_resistor(fc[i], fc[i + 1], R3)

        for j in range(0, n_guard - 1):
            add_resistor(guards[j], guards[j + 1], R3)

        if n_guard > 0:
            add_resistor(guards[-1], fc[merge_index], R2)

        for i in range(merge_index, n_fc - 1):
            add_resistor(fc[i], fc[i + 1], R1)

        add_resistor(fc[-1], "Cathode", R_C)

    V_unknown = np.linalg.solve(G, b)

    voltages = dict(fixed_V)
    for name, idx in node_index.items():
        voltages[name] = float(V_unknown[idx])

    V1 = voltages[fc[0]]
    Vc = fixed_boundaries[cathode_bc_name]["value"]
    drop_direct = V1 - Vc

    drop_fc_chain = 0.0
    for a, bnode in zip(fc, fc[1:]):
        drop_fc_chain += voltages[a] - voltages[bnode]
    drop_fc_chain += voltages[fc[-1]] - Vc

    print(f"[check] ΔV(TopRing→Cathode) (direct) = {drop_direct:.6g}")
    print(f"[check] ΔV via FieldCage chain      = {drop_fc_chain:.6g} (Δ = {drop_fc_chain - drop_direct:+.3e})")

    return voltages

bc_cathode = [i for i in boundaries_raw if 'cathode' in i.lower()][0]
fc_voltages = solve_fieldcage_network(
    fieldcage_names,
    guard_names,
    V_top=fixed_boundaries[top_fc_name]["value"],
    V_cathode=fixed_boundaries[bc_cathode]["value"],
    cathode_bc_name=bc_cathode,
)
# ============================================================
# 4. BUILD MATERIALS + BOUNDARIES DATA
# ============================================================

materials = {}
missing_material_eps = []
for name, meta in regions_raw.items():
    if name in volume_materials:
        materials[name] = {"attr_id": meta["attr_id"], "epsilon_r": volume_materials[name]}
    else:
        missing_material_eps.append(name)

if missing_material_eps:
    print("[warning] No epsilon_r specified for materials:")
    for name in sorted(missing_material_eps):
        print(f"  - {name}")

# Fixed boundaries output
boundaries_fixed_out = {}
for name, bc in fixed_boundaries.items():
    if name not in boundaries_raw:
        print(f"[warning] Fixed boundary '{name}' not found in phys_map; skipping.")
        continue
    tag = boundaries_raw[name]["bdr_id"]
    bcout = {"bdr_id": tag, "type": bc["type"]}

    if bc["type"] == "dirichlet":
        bcout["value"] = bc["value"]

    elif bc["type"] in ("neumann"):
        # simple constant Neumann
        if not bc.get("depth_dependent", False):
            bcout["value"] = bc["value"]
        # depth-dependent Neumann
        else:
            # keep the exact fields you provided
            bcout["depth_dependent"] = True
            bcout["z_bot"] = bc["z_bot"]
            bcout["z_top"] = bc["z_top"]
            bcout["value_bot"] = bc["value_bot"]
            bcout["value_top"] = bc["value_top"]
    boundaries_fixed_out[name] = bcout

# Rings/guards output
boundaries_rings = {}
for name in fieldcage_names:
    tag = boundaries_raw[name]["bdr_id"]
    boundaries_rings[name] = {"bdr_id": tag, "type": "dirichlet", "value": float(fc_voltages[name])}
for name in guard_names:
    tag = boundaries_raw[name]["bdr_id"]
    boundaries_rings[name] = {"bdr_id": tag, "type": "dirichlet", "value": float(fc_voltages[name])}

assigned_boundary_names = set(boundaries_fixed_out) | set(boundaries_rings)
unassigned_boundaries = sorted(name for name in boundaries_raw if name not in assigned_boundary_names)

if unassigned_boundaries:
    print("[warning] The following boundaries have no assigned voltage:")
    for name in unassigned_boundaries:
        tag = boundaries_raw[name]["bdr_id"]
        print(f"  - {name} (bdr_id={tag})")
else:
    print("[info] All boundaries in phys_map have an assigned voltage.")

# ============================================================
# 5. BUILD FIELDCAGE NETWORK DESCRIPTION FOR CONFIG
# ============================================================
fieldcage_names_sorted = fieldcage_names
guard_names_sorted = guard_names

n_fc = len(fieldcage_names_sorted)
n_guard = len(guard_names_sorted)

nodes_desc = []
edges_desc = []

if n_fc > 0:
    for name in fieldcage_names_sorted:
        nodes_desc.append({"name": name, "boundary": name, "fixed": (name == top_fc_name)})

for name in guard_names_sorted:
    nodes_desc.append({"name": name, "boundary": name, "fixed": False})

nodes_desc.append({"name": "Cathode", "boundary": bc_cathode, "fixed": True})

if n_fc > 0:
    fc = fieldcage_names_sorted
    guards = guard_names_sorted

    if n_fc < 8 or n_guard == 0:
        for i in range(n_fc - 1):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R1"})
        edges_desc.append({"n1": fc[-1], "n2": "Cathode", "R": "R_C"})
    else:
        for i in range(0, 4):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R1"})

        if n_fc > 5:
            edges_desc.append({"n1": fc[4], "n2": fc[5], "R": "R2"})
        if n_guard > 0:
            edges_desc.append({"n1": fc[4], "n2": guards[0], "R": "R2"})

        merge_index = n_fc - 3

        for i in range(5, merge_index):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R3"})
        for j in range(0, n_guard - 1):
            edges_desc.append({"n1": guards[j], "n2": guards[j + 1], "R": "R3"})

        if n_guard > 0:
            edges_desc.append({"n1": guards[-1], "n2": fc[merge_index], "R": "R2"})

        for i in range(merge_index, n_fc - 1):
            edges_desc.append({"n1": fc[i], "n2": fc[i + 1], "R": "R1"})

        edges_desc.append({"n1": fc[-1], "n2": "Cathode", "R": "R_C"})

# ============================================================
# 6. WRITE config_autogen.yaml (always)
# ============================================================

with output_path.open("w") as out:
    out.write("materials:\n")
    for m in sorted(materials):
        v = materials[m]
        out.write(f"  {m}:\n")
        out.write(f"    attr_id: {v['attr_id']}\n")
        out.write(f"    epsilon_r: {v['epsilon_r']}\n")

    out.write("\nboundaries:\n")

    for name in sorted(boundaries_fixed_out):
        v = boundaries_fixed_out[name]
        out.write(f"  {name}:\n")
        out.write(f"    bdr_id: {v['bdr_id']}\n")
        out.write(f"    type: {v['type']}\n")

        if v["type"] == "dirichlet":
            out.write(f"    value: {v['value']}\n")

        elif v["type"] in ("neumann"):
            if not v.get("depth_dependent", False):
                out.write(f"    value: {v['value']}\n")
            else:
                out.write(f"    depth_dependent: true\n")
                out.write(f"    z_bot: {v['z_bot']}\n")
                out.write(f"    z_top: {v['z_top']}\n")
                out.write(f"    value_bot: {v['value_bot']}\n")
                out.write(f"    value_top: {v['value_top']}\n")


    for name in boundaries_rings:
        if name in boundaries_fixed_out:
            continue
        v = boundaries_rings[name]
        out.write(f"  {name}:\n")
        out.write(f"    bdr_id: {v['bdr_id']}\n")
        out.write(f"    type: {v['type']}\n")
        out.write(f"    value: {v['value']}\n")

    out.write("\nfieldcage_network:\n")
    out.write("  enabled: true\n")

    out.write("  nodes:\n")
    for nd in nodes_desc:
        out.write(f"    - name: \"{nd['name']}\"\n")
        out.write(f"      boundary: \"{nd['boundary']}\"\n")
        out.write(f"      fixed: {str(nd['fixed']).lower()}\n")

    out.write("  resistors:\n")
    out.write(f"    R1: {R1}\n")
    out.write(f"    R2: {R2}\n")
    out.write(f"    R3: {R3}\n")
    out.write(f"    R_C: {R_C}\n")

    out.write("  edges:\n")
    for e in edges_desc:
        out.write(f"    - n1: \"{e['n1']}\"\n")
        out.write(f"      n2: \"{e['n2']}\"\n")
        out.write(f"      R: \"{e['R']}\"\n")

print(
    f"[done] Wrote {output_path} with {len(boundaries_rings)} FieldCage/guard boundaries "
    f"and {len(nodes_desc)} nodes / {len(edges_desc)} edges in fieldcage_network."
)

# ============================================================
# 7. OPTIONAL: AUTOAPPEND INTO ./config.yaml
# ============================================================

def yaml_dump(path: Path, data: dict) -> None:
    path.write_text(
        yaml.safe_dump(data, sort_keys=False, default_flow_style=False),
        encoding="utf-8",
    )

def mesh_autoappend_enabled(cfg: dict) -> bool:
    mesh = cfg.get("mesh", {})
    if not isinstance(mesh, dict):
        return False
    return bool(mesh.get("autoappend", False))

def apply_autogen_sections_inplace(cfg: dict, autogen: dict) -> dict:
    """
    Replace existing top-level sections if present, otherwise append them at the end
    (preserving existing key order as much as possible).
    """
    out = dict(cfg)  # preserves insertion order (Py3.7+)

    for key in ("materials", "boundaries", "fieldcage_network"):
        if key in out:
            out[key] = autogen[key]
        else:
            out[key] = autogen[key]  # appended at end

    return out
def resolve_and_update_mesh_path(cfg: dict, msh_path: Path) -> None:
    """
    If mesh.path exists in cfg, overwrite it with the resolved absolute path
    of msh_path. If msh_path does not exist, emit a colored warning.
    """
    mesh_cfg = cfg.get("mesh")
    if not isinstance(mesh_cfg, dict):
        return

    if not msh_path.exists():
        # yellow warning
        print(
            "\033[33m[warning]\033[0m mesh.path not updated: "
            f"{msh_path} does not exist."
        )
        return

    resolved = str(msh_path.resolve())
    mesh_cfg["path"] = resolved

if mesh_autoappend_enabled(cfg):
    autogen_sections = {
        "materials": materials,
        "boundaries": {**boundaries_fixed_out, **{k: boundaries_rings[k] for k in boundaries_rings}},
        "fieldcage_network": {
            "enabled": True,
            "nodes": nodes_desc,
            "resistors": {"R1": R1, "R2": R2, "R3": R3, "R_C": R_C},
            "edges": edges_desc,
        },
    }
    resolve_and_update_mesh_path(cfg, msh_path)

    new_cfg = apply_autogen_sections_inplace(cfg, autogen_sections)

    yaml_dump(config_path, new_cfg)
    print(f"[autoappend] Updated {config_path} (materials/boundaries/fieldcage_network).")
else:
    print(f"[autoappend] mesh.autoappend not enabled in {config_path}; no changes applied.")
